Practical No 03


#include <stdio.h> #define MAX 100
#define INF 1000000000 // A large number representing infinity

typedef struct { int pid;
int arrival_time; int burst_time;
int remaining_time; int completion_time; int turnaround_time; int waiting_time;
int started; // Optional: to track if process has started
} Process;
// Function to sort processes by arrival time void sortByArrival(Process p[], int n) {
Process temp;
for (int i = 0; i < n - 1; i++) { for (int j = i + 1; j < n; j++) {
if (p[i].arrival_time > p[j].arrival_time) { temp = p[i];
p[i] = p[j]; p[j] = temp;
}
}
}
}
// SJF Preemptive Scheduling
void sjfPreemptive(Process p[], int n) {
int completed = 0, current_time = 0, min_index; int min_burst;
int is_process_found;
float total_wt = 0, total_tat = 0;
for (int i = 0; i < n; i++) { p[i].remaining_time = p[i].burst_time; p[i].started = 0;
}
printf("\n--- Shortest Job First (Preemptive) Scheduling ---\n"); while (completed != n) {
min_burst = INF; min_index = -1;
is_process_found = 0;

for (int i = 0; i < n; i++) {
if (p[i].arrival_time <= current_time && p[i].remaining_time > 0) { if (p[i].remaining_time < min_burst) {
min_burst = p[i].remaining_time; min_index = i;
is_process_found = 1;
} else if (p[i].remaining_time == min_burst) {
if (p[i].arrival_time < p[min_index].arrival_time) { min_index = i;
 
}
}
}
}
if (is_process_found == 0) { current_time++; continue;
}

p[min_index].remaining_time--; current_time++;

if (p[min_index].remaining_time == 0) { completed++;
p[min_index].completion_time = current_time;
p[min_index].turnaround_time = p[min_index].completion_time - p[min_index].arrival_time; p[min_index].waiting_time = p[min_index].turnaround_time - p[min_index].burst_time; total_wt += p[min_index].waiting_time;
total_tat += p[min_index].turnaround_time;
}
}

printf("PID\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\n"); for (int i = 0; i < n; i++) {
printf("%d\t%d\t%d\t%d\t\t%d\t\t%d\n", p[i].pid, p[i].arrival_time,
p[i].burst_time, p[i].completion_time, p[i].turnaround_time, p[i].waiting_time);
}
printf("Average Turnaround Time = %.2f\n", total_tat / n); printf("Average Waiting Time = %.2f\n", total_wt / n);
}
// Round Robin Scheduling
void roundRobin(Process p[], int n, int quantum) { int current_time = 0, completed = 0;
int queue[MAX];
int front = 0, rear = 0; int visited[MAX] = {0};
float total_wt = 0, total_tat = 0;

for (int i = 0; i < n; i++) { p[i].remaining_time = p[i].burst_time;
}

printf("\n--- Round Robin Scheduling (Time Quantum = %d) ---\n", quantum); sortByArrival(p, n);
// Enqueue processes that have arrived at time 0 for (int i = 0; i < n; i++) {
if (p[i].arrival_time <= current_time && !visited[i]) { queue[rear++] = i;
visited[i] = 1;
}
}
if (rear == 0) {
current_time = p[0].arrival_time; queue[rear++] = 0;
visited[0] = 1;
 
}
while (completed != n) { if (front == rear) {
// Queue empty, advance time to next arrival for (int i = 0; i < n; i++) {
if (!visited[i]) {
current_time = p[i].arrival_time; queue[rear++] = i;
visited[i] = 1; break;
}
}
}
int idx = queue[front++];

if (p[idx].arrival_time > current_time) { current_time = p[idx].arrival_time;
}

int exec_time = (p[idx].remaining_time < quantum) ? p[idx].remaining_time : quantum; p[idx].remaining_time -= exec_time;
current_time += exec_time;
for (int i = 0; i < n; i++) {
if (!visited[i] && p[i].arrival_time <= current_time) { queue[rear++] = i;
visited[i] = 1;
}
}
if (p[idx].remaining_time == 0) { completed++;
p[idx].completion_time = current_time;
p[idx].turnaround_time = p[idx].completion_time - p[idx].arrival_time; p[idx].waiting_time = p[idx].turnaround_time - p[idx].burst_time; total_wt += p[idx].waiting_time;
total_tat += p[idx].turnaround_time;
} else {
queue[rear++] = idx;
}
}

printf("PID\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\n"); for (int i = 0; i < n; i++) {
printf("%d\t%d\t%d\t%d\t\t%d\t\t%d\n", p[i].pid, p[i].arrival_time,
p[i].burst_time, p[i].completion_time, p[i].turnaround_time, p[i].waiting_time);
}
printf("Average Turnaround Time = %.2f\n", total_tat / n); printf("Average Waiting Time = %.2f\n", total_wt / n);
}
int main() {
int n, choice, quantum;
printf("Enter number of processes: "); scanf("%d", &n);
Process p[MAX];
 
for (int i = 0; i < n; i++) { p[i].pid = i + 1;
printf("Enter arrival time of process %d: ", p[i].pid); scanf("%d", &p[i].arrival_time);
printf("Enter burst time of process %d: ", p[i].pid); scanf("%d", &p[i].burst_time);
}
printf("\nChoose Scheduling Algorithm:\n"); printf("1. Shortest Job First (Preemptive)\n"); printf("2. Round Robin\n");
printf("Enter choice: "); scanf("%d", &choice);
switch (choice) { case 1:
sjfPreemptive(p, n); break;
case 2:
printf("Enter time quantum: "); scanf("%d", &quantum); roundRobin(p, n, quantum); break;
default:
printf("Invalid choice\n"); break;
}
return 0;
}
 

 

